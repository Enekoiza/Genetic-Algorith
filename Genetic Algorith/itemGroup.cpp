#include "itemGroup.h"



// Constructor that will be used to generate new itemGroup while running the environment.run()
itemGroup::itemGroup(vector<item*> solution)
{
	solutionFitness = new int;
	solutionLenght = new int;

	*solutionLenght = 25;

	// Place the parameter solution into the class variable solution
	this->solution = solution;
	
	int fitness = 0;
	int solutionWeight = 0;


	// Iterate through all the item and calculate the total value and total weight.
	for (auto i : solution)
	{
		// Only get the value and weight from the item where the genetic value = 1
		if (*i->getGeneticValue() == 1)
		{
			fitness += *i->getValue();
			solutionWeight += *i->getWeight();
		}
	}

	//If the weight is bigger than 4000, the solution fitness will be set to 0
	if (solutionWeight > 4000)
	{
		*solutionFitness = 0;
	}
	// Otherwise the calculated summatory will be put inside the solutionFitness var
	else
	{
		*solutionFitness = fitness;
	}

}


// Constructor that will be used while creating the item group from the given .csv file
itemGroup::itemGroup(string fileName)
{

	solutionFitness = new int;
	solutionLenght = new int;

	*solutionLenght = 25;


	fstream file;

	string itemName;
	int itemWeight;
	int itemValue;

	int title = 0;

	string token;

	file.open(fileName, std::ios::in);


	// Check if file is open
	if (file.is_open()) {
		string line;


		// Getlines until the end of the file
		while (getline(file, line))
		{

			// A title is expected, don't get it
			if (title == 0)
			{
				title = 1;
				continue;
			}


			// Convert the string generated by the getline into a stream to be able to be used again as a paramente inside the getline
			std::istringstream newStream(line);

			
			// The program expects that the file is a comma-separated file that has 3 values in each line
			// Get the 3 values and assign a variable to each one of them
			getline(newStream, token, ',');
			itemName = token;
			getline(newStream, token, ',');
			itemWeight = std::stoi(token);
			getline(newStream, token, ',');
			itemValue = std::stoi(token);
			
			// Push a new item pointer into the solution. The last value as specified in the item.h file is the geneticValue that must be randomly generated betwen the values 0 and 1
			solution.push_back(new item(itemName, itemWeight, itemValue, rand() % 2));
		}

		// Close the file
		file.close();
	}

	int fitness = 0;
	int solutionWeight = 0;


	// Calculate the total weight and the total value
	for (auto i : solution)
	{
		// Only get the values where the genetic value = 1
		if(*i->getGeneticValue() == 1)
		{
			fitness += *i->getValue();
			solutionWeight += *i->getWeight();
		}
	}
	
	// The solution fitness will be set to 0 if the weight of the solution surpasses the limit stated of 4000
	if (solutionWeight > 4000)
	{
		*solutionFitness = 0;
	}
	// The case that the weight does not surpass it, the solution fitness will be the calculated summatory
	else
	{
		*solutionFitness = fitness;
	}
}


// Destructor to get rid of all the pointer that are inside the solution
itemGroup::~itemGroup()
{
	// Iterate through all the pointers that form the solution vector and delete each one of them
	for (int j = solution.size() - 1; j >= 0; j--) if (solution[j] != NULL) delete solution[j];

	if (solutionFitness != NULL) delete solutionFitness;
	if (solutionLenght != NULL) delete solutionLenght;
}


// A funtion that returns the solution vector
vector<item*> itemGroup::getSolution()
{
	return solution;
}


// A function that will return the summatory value of all the items which have the geneticValue = 1
int itemGroup::getTotalValue()
{
	int total = 0;


	// Calculate the summatory value of all the items and return it
	for (auto i : solution)
	{
		// Only get the ones that have the genetic value = 1
		if (*i->getGeneticValue() == 1)
		{
			total += *i->getValue();
		}

	}

	return total;
}


// A function that will return the summatory weight of all the items which have the geneticValue = 1
int itemGroup::getTotalWeight()
{
	int total = 0;

	// Calculate the summatory weight of all the value and return it
	for (auto i : solution)
	{

		// Only get the ones that have the genetic value = 1
		if (*i->getGeneticValue() == 1)
		{
			total += *i->getWeight();
		}

	}

	return total;
}


// A funtion to return the solution fitness
int itemGroup::getSolutionFitness()
{
	return *solutionFitness;
}


// A function that returns the solution lenght
int itemGroup::getSolutionLenght()
{
	return *solutionLenght;
}

